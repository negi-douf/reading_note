# chapter_6: CPU design preparation

## CPUの仕様

- 演算とデータ移動は 4bit単位
- レジスタAと Bはともに 4bit
- 1bitのキャリーフラグがある
- 命令のフォーマット
  - 全体で 8bit
  - 上位 4bitがオペレーションコード
  - 下位 4bitがイミディエイトデータ  
  不要な場合は 0で満たされる
- 命令一覧
  - 0000: ADD A, Im (A <- A + Im)  
  - 0101: ADD B, Im
  - 0011: MOV A, Im (A <- Im)
  - 0111: MOV B, Im
  - 0001: MOV A, B
  - 0100: MOV B, A
  - 1111: JMP Im (絶対アドレスを指定して、特定のアドレスにジャンプ)
  - 1110: JNC Im (Cフラグがセットされていないときにジャンプ)  
  - 0010: IN A (入力ポートからレジスタAに転送)
  - 0110: IN B
  - 1001: OUT B (レジスタBのデータを出力ポートへ転送)
  - 1011: OUT Im

この CPUを TD4とよぶこととする

## 機械語とは

CPUが直接実行できるプログラムのこと  
人間の書いたコードは機械語に変換される  

たとえば、レジスタAに 0001を書き込みたいとする  
その場合、TD4で実行する命令は `00110001` となる  
レジスタAに書き込む `0011` という命令に `0001` というオペランドがくっついてくる形  
今後はこれを `MOV A, 0001` と表記する

”MOV" のような略字をニーモニックとよぶ  

ビット数の多い CPUでは、機械語は 16進数で書かれたりもするらしい  

`2 + 3` という計算を実行したいとしたら、

```
MOV A, 0010
ADD A, 0011
```

という 2つの命令を実行する必要がある  

CPUは 0番地の命令から順に実行するため、最初に実行したいものを 0番地に書き込んでおけばいい  
CPUにリセットをかけると、 0番地から順に命令が読み取られて実行される  

命令は上から順に最後まで実行される  
特定の一でプログラムを終了させたい場合、自身のアドレスにジャンプさせる命令を書く  

加算時に桁溢れが発生した場合、キャリーフラグを 1にする  
加算結果が 16、つまり `10000` になったとき、レジスタの値は `0000` となってしまう  
その場合、キャリーフラグが立っているおかげで、「レジスタの値は 9以下か？」といった判定も正しくおこなうことができる  
なお、"JNC" の命令は "Jump if Not Carry" の略で、Cフラグが 0のときにジャンプが実行される

現在どの番地の命令を実行しているかの値は、プラグラムカウンタが保持している  
命令を実行するたびに 1が加算され、リセットで 0に戻る  
(ジャンプのときにも書き換えられる？)
